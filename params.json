{"name":"Rsa","tagline":"Cryptography‬","body":"### Welcome to GitHub Pages.\r\n### Progam 1: **[RSA](http://en.wikipedia.org/wiki/RSA_problem)**\r\nChương trình cài đặt hàm cửa sập RSA thỏa mãn:\r\n* Các số nguyên tố `p, q` là số `3072` bits, có nghĩa rằng modulo `N` khoảng `6142` bits.\r\n> Chú ý: Trên thực tế N khoảng 2048 bit là đủ an toàn. Ở đây ta sử dụng số N lớn chỉ nhằm để test hiệu năng chương trình.\r\n* Khóa bí mật `(N, d)` thỏa mãn `d > N^(1/4)`.\r\n* Khóa công khai `(N, e)` thỏa mãn `e > 3`.\r\n<br/><br/>\r\n**Thuật toán**<br/>\r\n**RSA Encode** `((N, e),m)`<br/>\r\nInput:<br/>\r\n1. `(N,e)`   RSA public key\r\n2. `m`   message representative, an integer between `0` and `N-1`\r\n<br/>Output: <br/> c   ciphertext representative, an integer between `0` and `N-1`\r\n\r\n**Encode**:\r\n```java\r\n        p = new GenPrime().genPrime(bitlen/2);\r\n\t\tq = new GenPrime().genPrime(bitlen/2);\r\n\t\tn = p.multiply(q);\r\n\t\tBigInteger m = (p.subtract(BigInteger.ONE)).multiply(q\r\n\t\t\t\t.subtract(BigInteger.ONE)); // m = (p-1) * (q-1)\r\n\t\t\r\n\t\te = new BigInteger(\"3\");\r\n\t\twhile (m.gcd(e).intValue() > 1) {\r\n\t\t\te = e.add(new BigInteger(\"2\"));\r\n\t\t}\r\n\t\td = e.modInverse(m);\r\n```\r\n\r\n**Decode** :boom: :boom: :boom:\r\n```java\r\n    public synchronized String decrypt(String message) {\r\n\t\treturn new String((new BigInteger(message)).modPow(d, n).toByteArray());\r\n\t}\r\n```\r\n***\r\n### Progam 2: Probable Prime\r\nDùng giải thuật [Miller-Rabin](http://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test)\r\n<br/>\r\n```\r\nInput: n > 3, an odd integer to be tested for primality;\r\nInput: k, a parameter that determines the accuracy of the test\r\nOutput: composite if n is composite, otherwise probably prime\r\nwrite n − 1 as 2^s*d with d odd by factoring powers of 2 from n − 1\r\nWitnessLoop: repeat k times:\r\n   pick a random integer a in the range [2, n − 2]\r\n   x ← a^d mod n\r\n   if x = 1 or x = n − 1 then do next WitnessLoop\r\n   repeat s − 1 times:\r\n      x <- x^2 mod n\r\n      if x = 1 then return composite\r\n      if x = n − 1 then do next WitnessLoop\r\n   return composite\r\nreturn probably prime\r\n```\r\n**Code** <br/>\r\n```java\r\npublic static boolean millerRabin(BigInteger n, int numValues) { \r\n\t\tBigInteger d = n.subtract(ONE);\r\n\t\tint s = 0;\r\n\t\twhile (d.mod(TWO).equals(ZERO)) {\r\n\t\t\ts++;\r\n\t\t\td = d.divide(TWO);\r\n\t\t}\r\n\t\t\r\n\t\tfor (int i = 0; i < aValues.length; i++) {\r\n\t\t\tif(n.compareTo(BigInteger.valueOf(aValues[i]))==0)\r\n\t\t\t\treturn true;\r\n\t\t\tif (n.mod(BigInteger.valueOf(aValues[i]))\r\n\t\t\t\t\t.compareTo(BigInteger.ZERO) == 0)\r\n\t\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(\"Base Over\");\r\n\t\tfor (int i = 0; i < numValues; i++) {\r\n\t\t\t//BigInteger a = BigInteger.valueOf(aValues[i]);// random\r\n\t\t\tBigInteger a =  randomBigInteger(n);\r\n\t\t\tboolean r = testPrime(n, a, s, d);\r\n\t\t\tif (!r) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n```\r\n***\r\n### Progam 3: Chia sẻ file\r\nXây dựng chương trình mã hóa file cho phép nhiều người dùng có thể giải mã.\r\n<br/>Giả sử người dùng **A** muốn mã hóa file _f_ cho phép cả người dùng **B** và **C** có thể giải mã. Chị ta làm như sau:\r\n* Sinh ngẫu nhiên khóa `k` và mã hoá file _f_ dùng hệ mã đối xứng an toàn `(E, D)`. Ta được file\r\n<br/>                 `g = E(k, f)`\r\n> Ví dụ: **E** có thể là `AES-CBC mode` hoặc `AES-CRT mode`.\r\n* Dùng sở đồ `RSA-OAEP` với khóa công khai của người dùng **A**, **B** và **C** để mã hóa khóa `k`\r\nthành `kA`, `kB` và `kC`, tương ứng cho mỗi người. Ghép file `g` với `kA`, `kB` và `kC` ta được file\r\n<br/>                 `x = g‖kA‖kB‖kC`\r\n<br/>Người dùng **B** (tương ứng **C**) có thể tính `k` từ file `x` và khóa bí mật `kB` (tương ứng `kC` ). Từ đó\r\nchị ta giải mã `f = D(k, g)`.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}